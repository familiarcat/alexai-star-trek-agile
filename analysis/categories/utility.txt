# ========================================
# SCRIPT: bilateral-learning-monitor.sh
# PATH: bilateral-learning-monitor.sh
# CATEGORY: utility
# REASON: Contains utility/helper keywords
# LINES: 84
# FUNCTIONS: 8
# ========================================

#!/bin/bash

# üîß Enhanced with Chief Engineer Scott's Robustness Features
# Prevents command and dquote errors through strict error handling
set -euo pipefail  # Strict error handling: exit on error, undefined vars, pipe failures

# Error handling function
handle_error() {
    local exit_code=$?
    local line_number=$1
    echo "‚ùå Error occurred in script at line $line_number (exit code: $exit_code)" >&2
    exit $exit_code
}

# Set error trap
trap 'handle_error $LINENO' ERR

# Logging functions
log_info() {
    echo "‚ÑπÔ∏è  $1"
}

log_success() {
    echo "‚úÖ $1"
}

log_warning() {
    echo "‚ö†Ô∏è  $1"
}

log_error() {
    echo "‚ùå $1"
}

# Variable validation function
validate_vars() {
    local required_vars=("$@")
    for var in "${required_vars[@]}"; do
        if [[ -z "${!var:-}" ]]; then
            log_error "Required variable '$var' is not set"
            exit 1
        fi
    done
}

# Command validation function
validate_command() {
    if ! command -v "$1" >/dev/null 2>&1; then
        log_error "Required command '$1' is not available"
        exit 1
    fi
}

# Safe command execution with error checking
safe_exec() {
    "$@"
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        log_error "Command failed with exit code $exit_code: $*"
        return $exit_code
    fi
    return 0
}


#!/bin/zsh
# Continuous Bilateral Learning Monitor

while true; do
    # Watch for new .md files
    find . -name "*.md" -newer alexai-knowledge-base/BILATERAL_LEARNING_LOG.md -not -path "./node_modules/*" | while read -r file; do
        echo "New markdown file detected: $file"
        ./scripts/knowledge/bilateral-learning-system.sh process "$file" "markdown"
    done
    
    # Watch for new .sh files
    find . -name "*.sh" -newer alexai-knowledge-base/BILATERAL_LEARNING_LOG.md -not -path "./node_modules/*" | while read -r file; do
        echo "New shell script detected: $file"
        ./scripts/knowledge/bilateral-learning-system.sh process "$file" "shell"
    done
    
    # Wait before next check
    sleep 30
done

# ========================================
# SCRIPT: sync-health-check.sh
# PATH: scripts/monitoring/sync-health-check.sh
# CATEGORY: utility
# REASON: Contains utility/helper keywords
# LINES: 118
# FUNCTIONS: 8
# ========================================

#!/bin/bash

# üîß Enhanced with Chief Engineer Scott's Robustness Features
# Prevents command and dquote errors through strict error handling
set -euo pipefail  # Strict error handling: exit on error, undefined vars, pipe failures

# Error handling function
handle_error() {
    local exit_code=$?
    local line_number=$1
    echo "‚ùå Error occurred in script at line $line_number (exit code: $exit_code)" >&2
    exit $exit_code
}

# Set error trap
trap 'handle_error $LINENO' ERR

# Logging functions
log_info() {
    echo "‚ÑπÔ∏è  $1"
}

log_success() {
    echo "‚úÖ $1"
}

log_warning() {
    echo "‚ö†Ô∏è  $1"
}

log_error() {
    echo "‚ùå $1"
}

# Variable validation function
validate_vars() {
    local required_vars=("$@")
    for var in "${required_vars[@]}"; do
        if [[ -z "${!var:-}" ]]; then
            log_error "Required variable '$var' is not set"
            exit 1
        fi
    done
}

# Command validation function
validate_command() {
    if ! command -v "$1" >/dev/null 2>&1; then
        log_error "Required command '$1' is not available"
        exit 1
    fi
}

# Safe command execution with error checking
safe_exec() {
    "$@"
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        log_error "Command failed with exit code $exit_code: $*"
        return $exit_code
    fi
    return 0
}


#!/bin/bash

# üîç Enhanced Bilateral Sync Health Check
# Quick status check without running full sync operations

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$(dirname "$SCRIPT_DIR")")"
SYNC_SCRIPT="$PROJECT_ROOT/bilateral-sync/scripts/enhanced-sync-manager.js"

echo "üîç Enhanced Bilateral Sync Health Check"
echo "======================================"

# Check if sync script exists
if [[ ! -f "$SYNC_SCRIPT" ]]; then
    echo "‚ùå Sync script not found: $SYNC_SCRIPT"
    exit 1
fi

# Check Node.js availability
if ! command -v node &> /dev/null; then
    echo "‚ùå Node.js not found"
    exit 1
fi

# Check sync status
echo ""
echo "üìä Sync Status:"
node "$SYNC_SCRIPT" status

# Check configuration
echo ""
echo "‚öôÔ∏è  Configuration:"
node "$SYNC_SCRIPT" config

# Check recent activity
echo ""
echo "üìã Recent Activity:"
node "$SYNC_SCRIPT" logs

# Check system resources
echo ""
echo "üíª System Resources:"
echo "Memory Usage:"
free -h | grep -E "Mem|Swap" || echo "Memory info not available"

echo ""
echo "Disk Usage:"
df -h . | head -2

echo ""
echo "‚úÖ Health check completed"

# ========================================
# SCRIPT: safe-echo.sh
# PATH: scripts/utils/safe-echo.sh
# CATEGORY: utility
# REASON: Contains utility/helper keywords
# LINES: 100
# FUNCTIONS: 6
# ========================================

#!/bin/zsh

# üõ°Ô∏è Safe Echo Utilities
# Prevents cmdand/dquote errors in shell scripts

# Function: Safe header printing
print_header() {
    local title="$1"
    local subtitle="${2:-}"
    
    echo "üöÄ $title"
    echo "==============================="
    if [[ -n "$subtitle" ]]; then
        echo "$subtitle"
    fi
    echo ""
}

# Function: Safe section printing
print_section() {
    local title="$1"
    local emoji="${2:-üìã}"
    
    echo "$emoji $title"
    echo "$(printf '=%.0s' {1..${#title}})"
    echo ""
}

# Function: Safe status messages
print_status() {
    local msg_type="$1"
    local message="$2"
    
    case "$msg_type" in
        "success"|"ok"|"‚úÖ")
            echo "‚úÖ $message"
            ;;
        "error"|"fail"|"‚ùå")
            echo "‚ùå $message"
            ;;
        "warning"|"warn"|"‚ö†Ô∏è")
            echo "‚ö†Ô∏è $message"
            ;;
        "info"|"‚ÑπÔ∏è")
            echo "‚ÑπÔ∏è $message"
            ;;
        "working"|"‚è≥")
            echo "‚è≥ $message"
            ;;
        *)
            echo "$msg_type $message"
            ;;
    esac
}

# Function: Safe command execution with status
safe_execute() {
    local description="$1"
    shift
    local command=("$@")
    
    print_status "‚è≥" "$description..."
    
    if "${command[@]}"; then
        print_status "‚úÖ" "$description completed"
        return 0
    else
        print_status "‚ùå" "$description failed"
        return 1
    fi
}

# Function: Safe multi-line output
print_multiline() {
    local content="$1"
    
    # Use printf to safely handle multi-line content
    printf "%s\n" "$content"
}

# Function: Safe list printing
print_list() {
    local title="$1"
    shift
    local items=("$@")
    
    echo "$title:"
    for item in "${items[@]}"; do
        echo "  ‚Ä¢ $item"
    done
    echo ""
}

# Export functions for use in other scripts
export -f print_header
export -f print_section
export -f print_status
export -f safe_execute
export -f print_multiline
export -f print_list

# ========================================
# SCRIPT: fix-corrupted-workflows.sh
# PATH: scripts/validation/fix-corrupted-workflows.sh
# CATEGORY: utility
# REASON: Contains utility/helper keywords
# LINES: 118
# FUNCTIONS: 3
# ========================================

#!/bin/bash

# Fix Corrupted Workflow Files Script
# This script identifies and fixes corrupted workflow JSON files

set -e

echo "üîß Fixing Corrupted Workflow Files"
echo "=================================="

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to check if a file is valid JSON
check_json() {
    local file="$1"
    if python3 -m json.tool "$file" > /dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# Function to backup a file
backup_file() {
    local file="$1"
    local backup="${file}.backup.$(date +%Y%m%d_%H%M%S)"
    cp "$file" "$backup"
    echo -e "${YELLOW}üì¶ Backed up: $backup${NC}"
}

# Function to try to fix a corrupted JSON file
fix_json_file() {
    local file="$1"
    local temp_file="${file}.temp"
    
    echo -e "${YELLOW}üîß Attempting to fix: $(basename "$file")${NC}"
    
    # Try to read the file and identify the issue
    if ! python3 -m json.tool "$file" 2>&1 | head -10; then
        echo -e "${RED}‚ùå JSON validation failed${NC}"
    fi
    
    # Try to fix common JSON issues
    # Remove trailing commas
    sed 's/,\([[:space:]]*[}\]])/\1/g' "$file" > "$temp_file"
    
    # Remove BOM if present
    sed '1s/^\xEF\xBB\xBF//' "$temp_file" > "${temp_file}.2"
    mv "${temp_file}.2" "$temp_file"
    
    # Try to validate the fixed version
    if check_json "$temp_file"; then
        echo -e "${GREEN}‚úÖ Fixed successfully!${NC}"
        backup_file "$file"
        mv "$temp_file" "$file"
        return 0
    else
        echo -e "${RED}‚ùå Could not fix automatically${NC}"
        rm -f "$temp_file"
        return 1
    fi
}

# Check both workflow directories
WORKFLOW_DIRS=("sync-system/workflows" "workflows")
TOTAL_FILES=0
CORRUPTED_FILES=0
FIXED_FILES=0

for dir in "${WORKFLOW_DIRS[@]}"; do
    if [ ! -d "$dir" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Directory not found: $dir${NC}"
        continue
    fi
    
    echo -e "\nüîç Checking directory: $dir"
    echo "----------------------------------------"
    
    # Find all JSON files
    find "$dir" -name "*.json" -type f | while read -r file; do
        TOTAL_FILES=$((TOTAL_FILES + 1))
        echo -n "Checking: $(basename "$file") ... "
        
        if check_json "$file"; then
            echo -e "${GREEN}‚úÖ Valid${NC}"
        else
            echo -e "${RED}‚ùå Corrupted${NC}"
            CORRUPTED_FILES=$((CORRUPTED_FILES + 1))
            
            # Try to fix the file
            if fix_json_file "$file"; then
                FIXED_FILES=$((FIXED_FILES + 1))
            fi
        fi
    done
done

echo -e "\nüìä Summary"
echo "=========="
echo -e "Total files checked: ${TOTAL_FILES}"
echo -e "Corrupted files found: ${CORRUPTED_FILES}"
echo -e "Files fixed: ${FIXED_FILES}"
echo -e "Files still corrupted: $((CORRUPTED_FILES - FIXED_FILES))"

if [ $CORRUPTED_FILES -eq 0 ]; then
    echo -e "\n${GREEN}üéâ All workflow files are valid!${NC}"
elif [ $FIXED_FILES -eq $CORRUPTED_FILES ]; then
    echo -e "\n${GREEN}üéâ All corrupted files were fixed!${NC}"
else
    echo -e "\n${RED}‚ö†Ô∏è  Some files could not be fixed automatically${NC}"
    echo "Check the backup files and fix manually if needed."
fi

echo -e "\n‚ú® Workflow validation complete!"

# ========================================
# SCRIPT: validate-script-robustness.sh
# PATH: scripts/validation/validate-script-robustness.sh
# CATEGORY: utility
# REASON: Contains utility/helper keywords
# LINES: 105
# FUNCTIONS: 6
# ========================================

#!/bin/bash

# üîç SCRIPT ROBUSTNESS VALIDATOR
# Chief Engineer Scott's Tool for Validating Script Quality

set -euo pipefail

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() { echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"; }
log_success() { echo -e "${GREEN}‚úÖ $1${NC}"; }
log_warning() { echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"; }
log_error() { echo -e "${RED}‚ùå $1${NC}"; }

validate_script() {
    local script_file="$1"
    local issues=0
    
    log_info "Validating: $(basename "$script_file")"
    
    # Check 1: Proper error handling
    if ! grep -q "set -e" "$script_file"; then
        log_warning "  Missing 'set -e' for error handling"
        ((issues++))
    fi
    
    # Check 2: Undefined variable handling
    if ! grep -q "set -u" "$script_file"; then
        log_warning "  Missing 'set -u' for undefined variable handling"
        ((issues++))
    fi
    
    # Check 3: Pipe failure handling
    if ! grep -q "set -o pipefail" "$script_file"; then
        log_warning "  Missing 'set -o pipefail' for pipe failure handling"
        ((issues++))
    fi
    
    # Check 4: Problematic nested command substitutions
    if grep -q '\$(echo "\$(.*)"' "$script_file"; then
        log_error "  Found problematic nested command substitution"
        ((issues++))
    fi
    
    # Check 5: Problematic eval usage
    if grep -q 'eval "\$(grep' "$script_file"; then
        log_error "  Found problematic eval pattern"
        ((issues++))
    fi
    
    # Check 6: Unquoted variables in echo
    if grep -q 'echo [^"]*\$[a-zA-Z_][a-zA-Z0-9_]*[^"]*$' "$script_file"; then
        log_warning "  Found unquoted variables in echo statements"
        ((issues++))
    fi
    
    # Check 7: Missing error traps
    if ! grep -q "trap.*ERR" "$script_file"; then
        log_warning "  Missing error trap for better error handling"
        ((issues++))
    fi
    
    if [[ $issues -eq 0 ]]; then
        log_success "  Script passed validation"
    else
        log_warning "  Script has $issues issue(s) to address"
    fi
    
    return $issues
}

# Main validation
main() {
    local scripts_dir="${1:-scripts}"
    local total_issues=0
    local total_scripts=0
    
    log_info "Starting script robustness validation..."
    
    while IFS= read -r -d '' script; do
        if [[ -f "$script" && -x "$script" ]]; then
            validate_script "$script"
            total_issues=$((total_issues + $?))
            ((total_scripts++))
        fi
    done < <(find "$scripts_dir" -name "*.sh" -type f -print0)
    
    echo ""
    log_info "Validation Summary:"
    echo "  Total scripts: $total_scripts"
    echo "  Total issues: $total_issues"
    
    if [[ $total_issues -eq 0 ]]; then
        log_success "All scripts passed validation!"
    else
        log_warning "Some scripts need attention"
    fi
}

main "$@"

# ========================================
# SCRIPT: validate-shell-scripts.sh
# PATH: scripts/validation/validate-shell-scripts.sh
# CATEGORY: utility
# REASON: Contains utility/helper keywords
# LINES: 214
# FUNCTIONS: 11
# ========================================

#!/bin/bash

# üîß Enhanced with Chief Engineer Scott's Robustness Features
# Prevents command and dquote errors through strict error handling
set -euo pipefail  # Strict error handling: exit on error, undefined vars, pipe failures

# Error handling function
handle_error() {
    local exit_code=$?
    local line_number=$1
    echo "‚ùå Error occurred in script at line $line_number (exit code: $exit_code)" >&2
    exit $exit_code
}

# Set error trap
trap 'handle_error $LINENO' ERR

# Logging functions
log_info() {
    echo "‚ÑπÔ∏è  $1"
}

log_success() {
    echo "‚úÖ $1"
}

log_warning() {
    echo "‚ö†Ô∏è  $1"
}

log_error() {
    echo "‚ùå $1"
}

# Variable validation function
validate_vars() {
    local required_vars=("$@")
    for var in "${required_vars[@]}"; do
        if [[ -z "${!var:-}" ]]; then
            log_error "Required variable '$var' is not set"
            exit 1
        fi
    done
}

# Command validation function
validate_command() {
    if ! command -v "$1" >/dev/null 2>&1; then
        log_error "Required command '$1' is not available"
        exit 1
    fi
}

# Safe command execution with error checking
safe_exec() {
    "$@"
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        log_error "Command failed with exit code $exit_code: $*"
        return $exit_code
    fi
    return 0
}


#!/bin/zsh

# üõ°Ô∏è Shell Script Validator
# Validates shell scripts against AlexAI standards

set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

echo "üõ°Ô∏è ALEXAI SHELL SCRIPT VALIDATOR"
echo "================================"
echo ""

# Function to validate a single script
validate_script() {
    local script_file="$1"
    local errors=0
    
    echo "üîç Validating: $script_file"
    echo "----------------------------"
    
    # Check 1: Echo chains with &&
    if grep -n "echo.*&&.*echo" "$script_file" > /dev/null; then
        echo "‚ùå Found echo chains with && (causes cmdand errors)"
        grep -n "echo.*&&.*echo" "$script_file" | head -3
        ((errors++))
    else
        echo "‚úÖ No problematic echo chains found"
    fi
    
    # Check 2: Complex command substitution in echo
    if grep -n "echo.*\$(.*)" "$script_file" | grep "&&" > /dev/null; then
        echo "‚ùå Found complex command substitution in echo chains"
        grep -n "echo.*\$(.*)" "$script_file" | grep "&&" | head -3
        ((errors++))
    else
        echo "‚úÖ No complex command substitution in echo chains"
    fi
    
    # Check 3: Unclosed quotes (basic check)
    if ! zsh -n "$script_file" 2>/dev/null; then
        echo "‚ùå Syntax errors detected (may include quote issues)"
        zsh -n "$script_file" 2>&1 | head -3
        ((errors++))
    else
        echo "‚úÖ Basic syntax validation passed"
    fi
    
    # Check 4: Missing set -e
    if ! grep -q "set -e" "$script_file"; then
        echo "‚ö†Ô∏è Missing 'set -e' for error handling"
        ((errors++))
    else
        echo "‚úÖ Error handling enabled"
    fi
    
    echo "Total issues: $errors"
    echo ""
    
    return $errors
}

# Function to fix common issues
fix_script() {
    local script_file="$1"
    local backup_file="${script_file}.backup"
    
    echo "üîß Fixing: $script_file"
    echo "---------------------"
    
    # Create backup
    cp "$script_file" "$backup_file"
    
    # Fix 1: Simple echo chain replacements
    # This is a basic fix - complex cases need manual review
    sed -i '' 's/echo "\([^"]*\)" && echo "\([^"]*\)"/echo "\1"; echo "\2"/g' "$script_file"
    
    echo "‚úÖ Basic fixes applied (backup: $backup_file)"
    echo ""
}

# Main validation
main() {
    local fix_mode=false
    local total_errors=0
    
    if [[ "$1" == "--fix" ]]; then
        fix_mode=true
        echo "üîß Fix mode enabled"
        echo ""
    fi
    
    # Find all shell scripts
    echo "üìã Finding shell scripts..."
    local scripts=()
    while IFS= read -r -d '' script; do
        scripts+=("$script")
    done < <(find "$PROJECT_ROOT" -name "*.sh" -type f -print0)
    
    echo "Found ${#scripts[@]} shell scripts"
    echo ""
    
    # Validate each script
    for script in "${scripts[@]}"; do
        # Skip this validator script itself
        if [[ "$script" == "$0" ]]; then
            continue
        fi
        
        if $fix_mode; then
            fix_script "$script"
        fi
        
        if validate_script "$script"; then
            echo "‚úÖ $script - PASSED"
        else
            echo "‚ùå $script - FAILED"
            ((total_errors++))
        fi
        
        echo "----------------------------------------"
        echo ""
    done
    
    # Summary
    echo "üèÜ VALIDATION SUMMARY"
    echo "===================="
    echo "Total scripts: ${#scripts[@]}"
    echo "Scripts with issues: $total_errors"
    echo "Success rate: $(( (${#scripts[@]} - total_errors) * 100 / ${#scripts[@]} ))%"
    echo ""
    
    if [[ $total_errors -eq 0 ]]; then
        echo "‚úÖ All scripts passed validation!"
    else
        echo "‚ùå $total_errors scripts need attention"
        echo ""
        echo "üîß RECOMMENDED ACTIONS:"
        echo "1. Review scripts marked as FAILED"
        echo "2. Apply AlexAI Shell Script Standards"
        echo "3. Re-run validation after fixes"
        echo "4. Use --fix flag for automatic basic fixes"
    fi
    
    return $total_errors
}

main "$@"

# ========================================
# SCRIPT: test-simple.sh
# PATH: test-simple.sh
# CATEGORY: utility
# REASON: Contains utility/helper keywords
# LINES: 69
# FUNCTIONS: 8
# ========================================

#!/bin/bash

# üîß Enhanced with Chief Engineer Scott's Robustness Features
# Prevents command and dquote errors through strict error handling
set -euo pipefail  # Strict error handling: exit on error, undefined vars, pipe failures

# Error handling function
handle_error() {
    local exit_code=$?
    local line_number=$1
    echo "‚ùå Error occurred in script at line $line_number (exit code: $exit_code)" >&2
    exit $exit_code
}

# Set error trap
trap 'handle_error $LINENO' ERR

# Logging functions
log_info() {
    echo "‚ÑπÔ∏è  $1"
}

log_success() {
    echo "‚úÖ $1"
}

log_warning() {
    echo "‚ö†Ô∏è  $1"
}

log_error() {
    echo "‚ùå $1"
}

# Variable validation function
validate_vars() {
    local required_vars=("$@")
    for var in "${required_vars[@]}"; do
        if [[ -z "${!var:-}" ]]; then
            log_error "Required variable '$var' is not set"
            exit 1
        fi
    done
}

# Command validation function
validate_command() {
    if ! command -v "$1" >/dev/null 2>&1; then
        log_error "Required command '$1' is not available"
        exit 1
    fi
}

# Safe command execution with error checking
safe_exec() {
    "$@"
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        log_error "Command failed with exit code $exit_code: $*"
        return $exit_code
    fi
    return 0
}


#!/bin/bash
echo "Hello World"
echo "Current directory: $(pwd)"
echo "Script directory: $(dirname "$0")"

