# ========================================
# SCRIPT: RESTART_SCRIPT.sh
# PATH: RESTART_SCRIPT.sh
# CATEGORY: setup
# REASON: Contains setup/installation keywords
# LINES: 103
# FUNCTIONS: 6
# ========================================

#!/bin/bash

# üöÄ AlexAI Star Trek Agile System - Restart Script
# Modern Next.js 15 Application
# Run this script after restarting your computer

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
PROJECT_NAME="alexai_katra_transfer_package_remote_v7"
NEXTJS_DIR="alexai-nextjs-modern"
NEXTJS_PORT=3000
OLD_PORT=8000

# Logging function
log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}"
}

warn() {
    echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] WARNING: $1${NC}"
}

error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: $1${NC}"
    exit 1
}

# Function to check if a command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Function to check if a port is in use
port_in_use() {
    lsof -ti:$1 >/dev/null 2>&1
}

# Function to kill processes on a port
kill_port() {
    if port_in_use $1; then
        log "Killing processes on port $1..."
        lsof -ti:$1 | xargs kill -9 2>/dev/null || true
        sleep 2
    fi
}

echo "üöÄ AlexAI Star Trek Agile System - Modern Next.js 15 Restart Script"
echo "=================================================================="

# Check if we're in the right directory
if [ ! -d "$NEXTJS_DIR" ]; then
    error "Next.js 15 directory not found. Please run this script from the project root."
fi

# Navigate to project directory
cd "$NEXTJS_DIR"

# Check Node.js installation
if ! command_exists node; then
    error "Node.js is not installed. Please install Node.js 18+ first."
fi

# Check npm installation
if ! command_exists npm; then
    error "npm is not installed. Please install npm first."
fi

# Display Node.js and npm versions
log "Node.js version: $(node --version)"
log "npm version: $(npm --version)"

# Kill any existing processes on ports
log "Cleaning up existing processes..."
kill_port $NEXTJS_PORT
kill_port $OLD_PORT

# Install dependencies
log "Installing dependencies..."
npm install

# Check if build is needed
if [ ! -d ".next" ]; then
    log "Building Next.js application..."
    npm run build
else
    log "Build directory exists, skipping build..."
fi

# Start the development server
log "Starting Next.js 15 development server..."
log "URL: http://localhost:$NEXTJS_PORT"
log "Press Ctrl+C to stop the server"

# Start the server
npm run dev 

# ========================================
# SCRIPT: enhanced-bilateral-sync.sh
# PATH: bilateral-sync/scripts/enhanced-bilateral-sync.sh
# CATEGORY: setup
# REASON: Contains setup/installation keywords
# LINES: 254
# FUNCTIONS: 14
# ========================================

#!/bin/bash

# üîß Enhanced with Chief Engineer Scott's Robustness Features
# Prevents command and dquote errors through strict error handling
set -euo pipefail  # Strict error handling: exit on error, undefined vars, pipe failures

# Error handling function
handle_error() {
    local exit_code=$?
    local line_number=$1
    echo "‚ùå Error occurred in script at line $line_number (exit code: $exit_code)" >&2
    exit $exit_code
}

# Set error trap
trap 'handle_error $LINENO' ERR

# Logging functions
log_info() {
    echo "‚ÑπÔ∏è  $1"
}

log_success() {
    echo "‚úÖ $1"
}

log_warning() {
    echo "‚ö†Ô∏è  $1"
}

log_error() {
    echo "‚ùå $1"
}

# Variable validation function
validate_vars() {
    local required_vars=("$@")
    for var in "${required_vars[@]}"; do
        if [[ -z "${!var:-}" ]]; then
            log_error "Required variable '$var' is not set"
            exit 1
        fi
    done
}

# Command validation function
validate_command() {
    if ! command -v "$1" >/dev/null 2>&1; then
        log_error "Required command '$1' is not available"
        exit 1
    fi
}

# Safe command execution with error checking
safe_exec() {
    "$@"
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        log_error "Command failed with exit code $exit_code: $*"
        return $exit_code
    fi
    return 0
}


#!/bin/bash

# üöÄ Enhanced Bilateral Sync with Auto-Credential Management
# Automatically sources ~/.zshrc credentials and maintains continuous sync

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"
SECURITY_MANAGER="${PROJECT_ROOT}/scripts/security/secure-environment-manager.sh"
SYNC_INTERVAL=${SYNC_INTERVAL:-300}  # 5 minutes default

echo "üöÄ ENHANCED BILATERAL SYNC STARTING"
echo "===================================="
echo "üõ°Ô∏è Integrated with Security Manager"
echo "üîÑ Auto-sync interval: $SYNC_INTERVAL seconds"
echo ""

# Function to update credentials from ~/.zshrc
update_credentials() {
    echo "üîê Updating credentials from ~/.zshrc..."
    
    if [[ -f "$SECURITY_MANAGER" ]]; then
        "$SECURITY_MANAGER" --validate-only
        echo "‚úÖ Credentials updated via security manager"
    else
        echo "‚ö†Ô∏è Security manager not found, using direct source"
        source ~/.zshrc
    fi
    
    # Export key variables for bilateral sync
    export N8N_API_KEY
    export N8N_BASE_URL
    export GITHUB_TOKEN
    export OPENAI_API_KEY
}

# Function to run bilateral sync
run_bilateral_sync() {
    echo "üîÑ $(date): Running enhanced bilateral sync..."
    
    # Update credentials first
    update_credentials
    
    # Run the bilateral sync manager
    cd "$PROJECT_ROOT/bilateral-sync"
    
    if node scripts/bilateral-sync-manager.js sync; then
        echo "‚úÖ $(date): Bilateral sync completed successfully"
        
        # Track evolution if significant changes detected
        if [[ -f "scripts/evolution-tracker.js" ]]; then
            node scripts/evolution-tracker.js report > /dev/null 2>&1
            echo "üìä Evolution tracking updated"
        fi
        
    else
        echo "‚ùå $(date): Bilateral sync failed"
    fi
    
    echo ""
}

# Function to validate environment
validate_environment() {
    echo "üîç Validating environment..."
    
    local required_vars=("N8N_API_KEY" "N8N_BASE_URL" "GITHUB_TOKEN")
    local missing_vars=()
    
    for var in "${required_vars[@]}"; do
        if [[ -z "${!var}" ]]; then
            missing_vars+=("$var")
        fi
    done
    
    if [[ ${#missing_vars[@]} -gt 0 ]]; then
        echo "‚ùå Missing required environment variables: ${missing_vars[*]}"
        echo "üîÑ Updating credentials from ~/.zshrc..."
        update_credentials
        
        # Check again
        for var in "${required_vars[@]}"; do
            if [[ -z "${!var}" ]]; then
                echo "‚ùå Still missing: $var"
                return 1
            fi
        done
    fi
    
    echo "‚úÖ Environment validation passed"
    return 0
}

# Function to setup systemd service (if running as root)
setup_systemd_service() {
    if [[ $EUID -eq 0 ]]; then
        echo "üîß Setting up systemd service..."
        
        local service_file="/etc/systemd/system/alexai-bilateral-sync.service"
        local current_service="${PROJECT_ROOT}/bilateral-sync/alexai-bilateral-sync.service"
        
        if [[ -f "$current_service" ]]; then
            cp "$current_service" "$service_file"
            systemctl daemon-reload
            systemctl enable alexai-bilateral-sync.service
            systemctl start alexai-bilateral-sync.service
            echo "‚úÖ Systemd service configured and started"
        else
            echo "‚ö†Ô∏è Service file not found: $current_service"
        fi
    fi
}

# Function to show status
show_status() {
    echo "üìä BILATERAL SYNC STATUS"
    echo "========================"
    echo "üïê Sync interval: $SYNC_INTERVAL seconds"
    echo "üõ°Ô∏è Security manager: $([ -f "$SECURITY_MANAGER" ] && echo "‚úÖ Available" || echo "‚ùå Not found")"
    echo "üìÅ Project root: $PROJECT_ROOT"
    echo "üîÑ Bilateral sync dir: ${PROJECT_ROOT}/bilateral-sync"
    
    # Check if running as service
    if systemctl is-active --quiet alexai-bilateral-sync.service 2>/dev/null; then
        echo "üöÄ Service status: ‚úÖ Active"
    else
        echo "üöÄ Service status: ‚ùå Inactive"
    fi
    
    echo ""
}

# Main execution
main() {
    echo "üéØ Starting enhanced bilateral sync system..."
    
    # Show initial status
    show_status
    
    # Validate environment
    if ! validate_environment; then
        echo "‚ùå Environment validation failed. Exiting."
        exit 1
    fi
    
    # Setup systemd service if running as root
    setup_systemd_service
    
    # Initial sync
    run_bilateral_sync
    
    echo "‚è∞ Starting continuous sync loop..."
    echo "Press Ctrl+C to stop"
    echo ""
    
    # Schedule regular syncs
    while true; do
        sleep $SYNC_INTERVAL
        run_bilateral_sync
    done
}

# Handle command line arguments
case "${1:-}" in
    --validate)
        validate_environment
        ;;
    --status)
        show_status
        ;;
    --setup-service)
        setup_systemd_service
        ;;
    --help)
        echo "Usage: $0 [OPTION]"
        echo "Options:"
        echo "  --validate      Validate environment only"
        echo "  --status        Show status only"
        echo "  --setup-service Setup systemd service (requires root)"
        echo "  --help          Show this help"
        echo ""
        echo "Default: Start continuous bilateral sync"
        exit 0
        ;;
    *)
        main "$@"
        ;;
esac

# ========================================
# SCRIPT: sync-scheduler.sh
# PATH: bilateral-sync/scripts/sync-scheduler.sh
# CATEGORY: setup
# REASON: Contains setup/installation keywords
# LINES: 102
# FUNCTIONS: 9
# ========================================

#!/bin/bash

# üîß Enhanced with Chief Engineer Scott's Robustness Features
# Prevents command and dquote errors through strict error handling
set -euo pipefail  # Strict error handling: exit on error, undefined vars, pipe failures

# Error handling function
handle_error() {
    local exit_code=$?
    local line_number=$1
    echo "‚ùå Error occurred in script at line $line_number (exit code: $exit_code)" >&2
    exit $exit_code
}

# Set error trap
trap 'handle_error $LINENO' ERR

# Logging functions
log_info() {
    echo "‚ÑπÔ∏è  $1"
}

log_success() {
    echo "‚úÖ $1"
}

log_warning() {
    echo "‚ö†Ô∏è  $1"
}

log_error() {
    echo "‚ùå $1"
}

# Variable validation function
validate_vars() {
    local required_vars=("$@")
    for var in "${required_vars[@]}"; do
        if [[ -z "${!var:-}" ]]; then
            log_error "Required variable '$var' is not set"
            exit 1
        fi
    done
}

# Command validation function
validate_command() {
    if ! command -v "$1" >/dev/null 2>&1; then
        log_error "Required command '$1' is not available"
        exit 1
    fi
}

# Safe command execution with error checking
safe_exec() {
    "$@"
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        log_error "Command failed with exit code $exit_code: $*"
        return $exit_code
    fi
    return 0
}


#!/bin/bash

# üïê Bilateral Sync Scheduler
# Automated scheduling for bilateral sync operations

SYNC_INTERVAL=${SYNC_INTERVAL:-300}  # 5 minutes default
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

echo "‚è∞ Bilateral Sync Scheduler Starting"
echo "Sync interval: $SYNC_INTERVAL seconds"
echo ""

# Function to run sync
run_sync() {
    echo "üîÑ $(date): Running bilateral sync..."
    
    if node "$SCRIPT_DIR/bilateral-sync-manager.js" sync; then
        echo "‚úÖ $(date): Sync completed successfully"
        
        # Track evolution if significant changes detected
        node "$SCRIPT_DIR/evolution-tracker.js" report > /dev/null 2>&1
        
    else
        echo "‚ùå $(date): Sync failed"
    fi
    
    echo ""
}

# Initial sync
run_sync

# Schedule regular syncs
while true; do
    sleep $SYNC_INTERVAL
    run_sync
done

# ========================================
# SCRIPT: update-credentials.sh
# PATH: bilateral-sync/scripts/update-credentials.sh
# CATEGORY: setup
# REASON: Contains setup/installation keywords
# LINES: 102
# FUNCTIONS: 8
# ========================================

#!/bin/bash

# üîß Enhanced with Chief Engineer Scott's Robustness Features
# Prevents command and dquote errors through strict error handling
set -euo pipefail  # Strict error handling: exit on error, undefined vars, pipe failures

# Error handling function
handle_error() {
    local exit_code=$?
    local line_number=$1
    echo "‚ùå Error occurred in script at line $line_number (exit code: $exit_code)" >&2
    exit $exit_code
}

# Set error trap
trap 'handle_error $LINENO' ERR

# Logging functions
log_info() {
    echo "‚ÑπÔ∏è  $1"
}

log_success() {
    echo "‚úÖ $1"
}

log_warning() {
    echo "‚ö†Ô∏è  $1"
}

log_error() {
    echo "‚ùå $1"
}

# Variable validation function
validate_vars() {
    local required_vars=("$@")
    for var in "${required_vars[@]}"; do
        if [[ -z "${!var:-}" ]]; then
            log_error "Required variable '$var' is not set"
            exit 1
        fi
    done
}

# Command validation function
validate_command() {
    if ! command -v "$1" >/dev/null 2>&1; then
        log_error "Required command '$1' is not available"
        exit 1
    fi
}

# Safe command execution with error checking
safe_exec() {
    "$@"
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        log_error "Command failed with exit code $exit_code: $*"
        return $exit_code
    fi
    return 0
}


#!/bin/bash

# üîê Automated Credential Update Script
# Sources credentials from ~/.zshrc and updates bilateral sync

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"
SECURITY_MANAGER="${PROJECT_ROOT}/scripts/security/secure-environment-manager.sh"

echo "üîê Updating credentials for bilateral sync..."

# Source credentials from ~/.zshrc
if [[ -f ~/.zshrc ]]; then
    source ~/.zshrc
    echo "‚úÖ Sourced credentials from ~/.zshrc"
else
    echo "‚ùå ~/.zshrc not found"
    exit 1
fi

# Update .env via security manager
if [[ -f "$SECURITY_MANAGER" ]]; then
    "$SECURITY_MANAGER" --validate-only
    echo "‚úÖ Updated .env via security manager"
else
    echo "‚ö†Ô∏è Security manager not found, using direct export"
fi

# Export key variables for bilateral sync
export N8N_API_KEY
export N8N_BASE_URL
export GITHUB_TOKEN
export OPENAI_API_KEY

echo "‚úÖ Credentials updated successfully"

# ========================================
# SCRIPT: activate-workflows.sh
# PATH: scripts/deploy/activate-workflows.sh
# CATEGORY: setup
# REASON: Contains setup/installation keywords
# LINES: 129
# FUNCTIONS: 0
0
# ========================================

#!/bin/bash

# Script to activate n8n workflows using different methods
set -e

echo "üîå ACTIVATING N8N WORKFLOWS"
echo "============================"

# Load environment variables
if [ -f .env ]; then
    source .env
    echo "‚úÖ Environment variables loaded"
else
    echo "‚ùå .env file not found"
    exit 1
fi

# Check required variables
if [ -z "$N8N_BASE_URL" ] || [ -z "$N8N_API_KEY" ]; then
    echo "‚ùå Missing required environment variables"
    echo "   N8N_BASE_URL: $N8N_BASE_URL"
    echo "   N8N_API_KEY: ${N8N_API_KEY:0:20}..."
    exit 1
fi

echo "üîó N8N URL: $N8N_BASE_URL"
echo "üîë API Key: ${N8N_API_KEY:0:20}..."

# List all workflows
echo ""
echo "üìã Listing all workflows..."
WORKFLOWS_RESPONSE=$(curl -s -H "X-N8N-API-KEY: $N8N_API_KEY" "$N8N_BASE_URL/api/v1/workflows")

if echo "$WORKFLOWS_RESPONSE" | jq -e '.data' > /dev/null 2>&1; then
    echo "‚úÖ Retrieved workflows successfully"
    
    # Show workflow status
    echo "$WORKFLOWS_RESPONSE" | jq -r '.data[] | "\(.name) - ID: \(.id) - Active: \(.active)"'
else
    echo "‚ùå Failed to retrieve workflows"
    echo "Response: $WORKFLOWS_RESPONSE"
    exit 1
fi

echo ""
echo "üîå Attempting to activate workflows..."

# Try different activation methods for each inactive workflow
echo "$WORKFLOWS_RESPONSE" | jq -r '.data[] | select(.active == false) | .id' | while read -r workflow_id; do
    if [ -n "$workflow_id" ]; then
        echo "üîÑ Attempting to activate workflow: $workflow_id"
        
        # Method 1: Try POST to /activate endpoint
        echo "   Trying POST activation..."
        ACTIVATE_RESPONSE=$(curl -s -X POST -H "X-N8N-API-KEY: $N8N_API_KEY" "$N8N_BASE_URL/api/v1/workflows/$workflow_id/activate" 2>/dev/null || echo "{}")
        
        if echo "$ACTIVATE_RESPONSE" | jq -e '.active == true' > /dev/null 2>&1; then
            echo "   ‚úÖ POST activation successful!"
        else
            echo "   ‚ùå POST activation failed: $(echo "$ACTIVATE_RESPONSE" | jq -r '.message // "Unknown error"')"
            
            # Method 2: Try to get workflow data and update it
            echo "   Trying to get workflow data..."
            WORKFLOW_DATA=$(curl -s -H "X-N8N-API-KEY: $N8N_API_KEY" "$N8N_BASE_URL/api/v1/workflows/$workflow_id")
            
            if echo "$WORKFLOW_DATA" | jq -e '.data' > /dev/null 2>&1; then
                echo "   ‚úÖ Retrieved workflow data"
                
                # Method 3: Try to update with active: true in the data
                echo "   Trying to update workflow with active status..."
                WORKFLOW_NAME=$(echo "$WORKFLOW_DATA" | jq -r '.data.name')
                WORKFLOW_NODES=$(echo "$WORKFLOW_DATA" | jq -r '.data.nodes')
                WORKFLOW_CONNECTIONS=$(echo "$WORKFLOW_DATA" | jq -r '.data.connections')
                WORKFLOW_SETTINGS=$(echo "$WORKFLOW_DATA" | jq -r '.data.settings')
                
                UPDATE_PAYLOAD=$(cat <<EOF
{
  "name": "$WORKFLOW_NAME",
  "nodes": $WORKFLOW_NODES,
  "connections": $WORKFLOW_CONNECTIONS,
  "settings": $WORKFLOW_SETTINGS
}
EOF
)
                
                UPDATE_RESPONSE=$(curl -s -X PUT \
                    -H "X-N8N-API-KEY: $N8N_API_KEY" \
                    -H "Content-Type: application/json" \
                    -d "$UPDATE_PAYLOAD" \
                    "$N8N_BASE_URL/api/v1/workflows/$workflow_id")
                
                if echo "$UPDATE_RESPONSE" | jq -e '.data' > /dev/null 2>&1; then
                    echo "   ‚úÖ Workflow updated successfully"
                    
                    # Check if it's now active
                    sleep 2
                    STATUS_CHECK=$(curl -s -H "X-N8N-API-KEY: $N8N_API_KEY" "$N8N_BASE_URL/api/v1/workflows/$workflow_id")
                    if echo "$STATUS_CHECK" | jq -e '.data.active == true' > /dev/null 2>&1; then
                        echo "   üéâ Workflow is now ACTIVE!"
                    else
                        echo "   ‚ö†Ô∏è  Workflow updated but still not active"
                    fi
                else
                    echo "   ‚ùå Failed to update workflow: $(echo "$UPDATE_RESPONSE" | jq -r '.message // "Unknown error"')"
                fi
            else
                echo "   ‚ùå Failed to retrieve workflow data"
            fi
        fi
        
        echo ""
    fi
done

echo ""
echo "üéØ ACTIVATION ATTEMPT COMPLETE"
echo "=============================="
echo ""
echo "üìã Final workflow status:"
FINAL_STATUS=$(curl -s -H "X-N8N-API-KEY: $N8N_API_KEY" "$N8N_BASE_URL/api/v1/workflows")
echo "$FINAL_STATUS" | jq -r '.data[] | "\(.name) - Active: \(.active)"'

echo ""
echo "üí° If workflows are still not active, you may need to:"
echo "   1. Activate them manually through the n8n web interface"
echo "   2. Check the n8n logs for any errors"
echo "   3. Verify the workflow configuration is correct"
echo ""
echo "üåê n8n web interface: $N8N_BASE_URL"

# ========================================
# SCRIPT: bootstrap.sh
# PATH: scripts/setup/bootstrap.sh
# CATEGORY: setup
# REASON: Contains setup/installation keywords
# LINES: 80
# FUNCTIONS: 8
# ========================================

#!/bin/bash

# üîß Enhanced with Chief Engineer Scott's Robustness Features
# Prevents command and dquote errors through strict error handling
set -euo pipefail  # Strict error handling: exit on error, undefined vars, pipe failures

# Error handling function
handle_error() {
    local exit_code=$?
    local line_number=$1
    echo "‚ùå Error occurred in script at line $line_number (exit code: $exit_code)" >&2
    exit $exit_code
}

# Set error trap
trap 'handle_error $LINENO' ERR

# Logging functions
log_info() {
    echo "‚ÑπÔ∏è  $1"
}

log_success() {
    echo "‚úÖ $1"
}

log_warning() {
    echo "‚ö†Ô∏è  $1"
}

log_error() {
    echo "‚ùå $1"
}

# Variable validation function
validate_vars() {
    local required_vars=("$@")
    for var in "${required_vars[@]}"; do
        if [[ -z "${!var:-}" ]]; then
            log_error "Required variable '$var' is not set"
            exit 1
        fi
    done
}

# Command validation function
validate_command() {
    if ! command -v "$1" >/dev/null 2>&1; then
        log_error "Required command '$1' is not available"
        exit 1
    fi
}

# Safe command execution with error checking
safe_exec() {
    "$@"
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        log_error "Command failed with exit code $exit_code: $*"
        return $exit_code
    fi
    return 0
}


#!/bin/bash
echo "üöÄ Starting AlexAI ‚Üí CursorAI bootstrap..."

chmod +x install.sh
./install.sh

source .venv/bin/activate

echo "üß† Scraping ~/Documents/workspace..."
python workspace_scraper.py

echo "‚öôÔ∏è Running CursorAI setup..."
bash cursorai_setup.sh

echo "‚úÖ Bootstrap complete! AlexAI is now operational inside CursorAI."

# ========================================
# SCRIPT: create-env-local.sh
# PATH: scripts/setup/create-env-local.sh
# CATEGORY: setup
# REASON: Contains setup/installation keywords
# LINES: 226
# FUNCTIONS: 12
# ========================================

#!/bin/bash

# üîß Enhanced with Chief Engineer Scott's Robustness Features
# Prevents command and dquote errors through strict error handling
set -euo pipefail  # Strict error handling: exit on error, undefined vars, pipe failures

# Error handling function
handle_error() {
    local exit_code=$?
    local line_number=$1
    echo "‚ùå Error occurred in script at line $line_number (exit code: $exit_code)" >&2
    exit $exit_code
}

# Set error trap
trap 'handle_error $LINENO' ERR

# Logging functions
log_info() {
    echo "‚ÑπÔ∏è  $1"
}

log_success() {
    echo "‚úÖ $1"
}

log_warning() {
    echo "‚ö†Ô∏è  $1"
}

log_error() {
    echo "‚ùå $1"
}

# Variable validation function
validate_vars() {
    local required_vars=("$@")
    for var in "${required_vars[@]}"; do
        if [[ -z "${!var:-}" ]]; then
            log_error "Required variable '$var' is not set"
            exit 1
        fi
    done
}

# Command validation function
validate_command() {
    if ! command -v "$1" >/dev/null 2>&1; then
        log_error "Required command '$1' is not available"
        exit 1
    fi
}

# Safe command execution with error checking
safe_exec() {
    "$@"
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        log_error "Command failed with exit code $exit_code: $*"
        return $exit_code
    fi
    return 0
}


#!/bin/bash

# üöÄ Create .env.local from Current Environment
# This script creates a .env.local file from the current shell environment
# for Next.js development while maintaining security

set -e

echo "üîß CREATING .ENV.LOCAL FROM CURRENT ENVIRONMENT"
echo "==============================================="

# Get the directory of this script
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"

# Check if we're in the right directory
if [[ ! -f "${PROJECT_ROOT}/package.json" ]]; then
    echo "‚ùå Not in project root directory"
    exit 1
fi

echo "‚úÖ Project root: $PROJECT_ROOT"

# Create .env.local with current environment variables
create_env_local() {
    local env_file="${PROJECT_ROOT}/.env.local"
    
    echo "üìù Creating .env.local..."
    
    cat > "$env_file" << EOF
# AlexAI Environment Configuration
# Generated from current shell environment on $(date)
# DO NOT COMMIT THIS FILE - it contains sensitive information

# n8n Integration
N8N_BASE_URL=${N8N_URL:-https://n8n.pbradygeorgen.com}
N8N_API_KEY=${N8N_API_KEY}

# AI Integration
OPENROUTER_API_KEY=${OPENROUTER_API_KEY}
OPENAI_API_KEY=${OPENAI_API_KEY}
GEMINI_API_KEY=${GEMINI_API_KEY}
BITO_API_KEY=${BITO_API_KEY}
CONTINUE_API_KEY=${CONTINUE_API_KEY}

# Application Configuration
NEXT_PUBLIC_APP_URL=http://localhost:3000
NEXT_PUBLIC_API_URL=http://localhost:3000/api

# Development Settings
NODE_ENV=development
NEXT_PUBLIC_DEBUG=true

# Database Configuration (if needed)
DATABASE_URL=sqlite:./agile_manager.db
EOF

    echo "‚úÖ Created .env.local with environment variables"
    echo "üìÅ File location: $env_file"
    
    # Add to .gitignore if not already there
    if ! grep -q ".env.local" "${PROJECT_ROOT}/.gitignore" 2>/dev/null; then
        echo ".env.local" >> "${PROJECT_ROOT}/.gitignore"
        echo "‚úÖ Added .env.local to .gitignore"
    fi
}

# Function to validate environment variables
validate_env() {
    echo ""
    echo "üîç VALIDATING ENVIRONMENT VARIABLES"
    echo "=================================="
    
    local missing_vars=()
    
    # Check required variables
    if [[ -z "$N8N_URL" && -z "$N8N_BASE_URL" ]]; then
        missing_vars+=("N8N_URL/N8N_BASE_URL")
    else
        echo "‚úÖ N8N URL: ${N8N_URL:-$N8N_BASE_URL}"
    fi
    
    if [[ -z "$N8N_API_KEY" ]]; then
        missing_vars+=("N8N_API_KEY")
    else
        echo "‚úÖ N8N_API_KEY: [SET]"
    fi
    
    if [[ -z "$OPENROUTER_API_KEY" ]]; then
        missing_vars+=("OPENROUTER_API_KEY")
    else
        echo "‚úÖ OPENROUTER_API_KEY: [SET]"
    fi
    
    if [[ ${#missing_vars[@]} -gt 0 ]]; then
        echo "‚ö†Ô∏è  Missing variables: ${missing_vars[*]}"
        echo "   These will be set to empty values in .env.local"
    fi
    
    echo ""
    echo "üìã Environment Summary:"
    echo "   - N8N Base URL: ${N8N_URL:-$N8N_BASE_URL:-https://n8n.pbradygeorgen.com}"
    echo "   - Next.js will run on: http://localhost:3000"
    echo "   - API endpoints: http://localhost:3000/api/*"
}

# Function to start Next.js
start_nextjs() {
    echo ""
    echo "üöÄ STARTING NEXT.JS DEVELOPMENT SERVER"
    echo "====================================="
    
    cd "$PROJECT_ROOT"
    
    echo "‚úÖ Environment configured successfully"
    echo "üéØ Starting Next.js development server..."
    echo ""
    
    # Start Next.js
    npm run dev
}

# Main execution
main() {
    echo "üéØ Starting environment configuration..."
    
    # Create .env.local
    create_env_local
    
    # Validate environment
    validate_env
    
    # Provide options
    echo ""
    echo "üéâ ENVIRONMENT CONFIGURATION COMPLETE!"
    echo "====================================="
    echo ""
    echo "üìã Available actions:"
    echo "  1. Start Next.js now (recommended)"
    echo "  2. Just create .env.local and exit"
    echo ""
    
    read -p "Choose an option (1-2): " choice
    
    case $choice in
        1)
            start_nextjs
            ;;
        2)
            echo "‚úÖ .env.local created successfully"
            echo "   You can now run: npm run dev"
            ;;
        *)
            echo "‚úÖ .env.local created successfully"
            echo "   You can now run: npm run dev"
            ;;
    esac
}

# Execute main function
main "$@"

# ========================================
# SCRIPT: cursorai_setup.sh
# PATH: scripts/setup/cursorai_setup.sh
# CATEGORY: setup
# REASON: Contains setup/installation keywords
# LINES: 6
# FUNCTIONS: 0
0
# ========================================

#!/bin/bash
echo "‚öôÔ∏è Setting up CursorAI environment..."
mkdir -p ~/.cursorai
cp workspace_embeddings.json ~/.cursorai/
cp alexai_cursor_bootstrapper.json ~/.cursorai/config.json
echo "‚úÖ CursorAI initialized with AlexAI memory and agents."

# ========================================
# SCRIPT: install.sh
# PATH: scripts/setup/install.sh
# CATEGORY: setup
# REASON: Contains setup/installation keywords
# LINES: 72
# FUNCTIONS: 8
# ========================================

#!/bin/bash

# üîß Enhanced with Chief Engineer Scott's Robustness Features
# Prevents command and dquote errors through strict error handling
set -euo pipefail  # Strict error handling: exit on error, undefined vars, pipe failures

# Error handling function
handle_error() {
    local exit_code=$?
    local line_number=$1
    echo "‚ùå Error occurred in script at line $line_number (exit code: $exit_code)" >&2
    exit $exit_code
}

# Set error trap
trap 'handle_error $LINENO' ERR

# Logging functions
log_info() {
    echo "‚ÑπÔ∏è  $1"
}

log_success() {
    echo "‚úÖ $1"
}

log_warning() {
    echo "‚ö†Ô∏è  $1"
}

log_error() {
    echo "‚ùå $1"
}

# Variable validation function
validate_vars() {
    local required_vars=("$@")
    for var in "${required_vars[@]}"; do
        if [[ -z "${!var:-}" ]]; then
            log_error "Required variable '$var' is not set"
            exit 1
        fi
    done
}

# Command validation function
validate_command() {
    if ! command -v "$1" >/dev/null 2>&1; then
        log_error "Required command '$1' is not available"
        exit 1
    fi
}

# Safe command execution with error checking
safe_exec() {
    "$@"
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        log_error "Command failed with exit code $exit_code: $*"
        return $exit_code
    fi
    return 0
}


#!/bin/bash
echo "üì¶ Installing Python environment..."
python3 -m venv .venv
source .venv/bin/activate
pip install --upgrade pip
pip install -r requirements.txt
echo "‚úÖ Environment ready."

# ========================================
# SCRIPT: robust-script-template.sh
# PATH: scripts/templates/robust-script-template.sh
# CATEGORY: setup
# REASON: Contains setup/installation keywords
# LINES: 98
# FUNCTIONS: 9
# ========================================

#!/bin/bash

# üìù ROBUST SCRIPT TEMPLATE
# Chief Engineer Scott's Template for Error-Free Scripts
# Use this template for all new scripts to prevent command and dquote errors

set -euo pipefail  # Strict error handling

# Script metadata
SCRIPT_NAME="$(basename "$0")"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"

# Error handling function
handle_error() {
    local exit_code=$?
    local line_number=$1
    echo "‚ùå Error occurred in $SCRIPT_NAME at line $line_number (exit code: $exit_code)" >&2
    exit $exit_code
}

# Set error trap
trap 'handle_error $LINENO' ERR

# Logging functions
log_info() {
    echo "‚ÑπÔ∏è  $1"
}

log_success() {
    echo "‚úÖ $1"
}

log_warning() {
    echo "‚ö†Ô∏è  $1"
}

log_error() {
    echo "‚ùå $1"
}

# Variable validation function
validate_vars() {
    local required_vars=("$@")
    for var in "${required_vars[@]}"; do
        if [[ -z "${!var:-}" ]]; then
            log_error "Required variable '$var' is not set"
            exit 1
        fi
    done
}

# Command validation function
validate_command() {
    if ! command -v "$1" >/dev/null 2>&1; then
        log_error "Required command '$1' is not available"
        exit 1
    fi
}

# Safe command execution with error checking
safe_exec() {
    "$@"
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        log_error "Command failed with exit code $exit_code: $*"
        return $exit_code
    fi
    return 0
}

# Main function
main() {
    log_info "Starting $SCRIPT_NAME..."
    
    # Validate required commands
    validate_command "curl"
    validate_command "jq"
    
    # Validate required environment variables
    # validate_vars "REQUIRED_VAR1" "REQUIRED_VAR2"
    
    # Your script logic here
    log_info "Performing main operations..."
    
    # Example: Safe command execution
    # safe_exec curl -s "http://localhost:3000/api/health"
    
    # Example: Safe variable usage
    # local result="$(safe_exec some_command)"
    
    log_success "$SCRIPT_NAME completed successfully"
}

# Script entry point
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi

