import { NextResponse } from 'next/server';
import path from 'path';
import { promises as fs } from 'fs';

// Project Context Management API
// Handles multi-client project separation and context switching

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const projectId = searchParams.get('projectId');
    const clientId = searchParams.get('clientId');
    const action = searchParams.get('action');
    
    if (action === 'list-projects') {
      return listAllProjects();
    }
    
    if (action === 'list-clients') {
      return listAllClients();
    }
    
    if (projectId && clientId) {
      return getProjectContext(clientId, projectId);
    }
    
    if (clientId) {
      return getClientProjects(clientId);
    }
    
    // Return available projects overview
    return getProjectsOverview();
    
  } catch (error) {
    console.error('Project context error:', error);
    return NextResponse.json(
      { error: 'Failed to retrieve project context' },
      { status: 500 }
    );
  }
}

export async function POST(request: Request) {
  try {
    const { action, clientId, projectId, projectData, contextSwitch } = await request.json();
    
    switch (action) {
      case 'create-project':
        return createProject(clientId, projectId, projectData);
      
      case 'switch-context':
        return switchProjectContext(clientId, projectId, contextSwitch);
      
      case 'update-project':
        return updateProjectContext(clientId, projectId, projectData);
      
      case 'archive-project':
        return archiveProject(clientId, projectId);
      
      default:
        return NextResponse.json(
          { error: 'Unknown action' },
          { status: 400 }
        );
    }
    
  } catch (error) {
    console.error('Project context update error:', error);
    return NextResponse.json(
      { error: 'Failed to update project context' },
      { status: 500 }
    );
  }
}

async function createProject(clientId: string, projectId: string, projectData: any) {
  const projectPath = path.join(
    process.cwd(),
    'alexai-knowledge-base',
    'projects',
    clientId,
    projectId
  );
  
  // Create project directory structure
  const directories = [
    'business-logic',
    'design-system', 
    'requirements',
    'agent-memories',
    'workflows',
    'documentation'
  ];
  
  for (const dir of directories) {
    await fs.mkdir(path.join(projectPath, dir), { recursive: true });
  }
  
  // Create project configuration
  const projectConfig = {
    clientId,
    projectId,
    projectName: projectData.projectName || projectId,
    domain: projectData.domain || 'general',
    status: 'active',
    createdAt: new Date().toISOString(),
    team: projectData.team || [],
    
    // Knowledge isolation settings
    knowledgeIsolation: {
      isolateBusinessLogic: true,
      isolateDesignSystem: true,
      shareUniversalKnowledge: true,
      allowCrossProjectLearning: false
    },
    
    // Agent configuration for this project
    agentConfiguration: {
      primaryAgents: projectData.primaryAgents || ['captain-picard', 'lieutenant-data'],
      specializations: projectData.specializations || {},
      memoryIsolation: true
    },
    
    // LCARS interface customization
    lcarsCustomization: {
      colorScheme: projectData.colorScheme || 'standard',
      panelConfiguration: projectData.panelConfiguration || 'standard',
      brandingElements: projectData.branding || {}
    }
  };
  
  await fs.writeFile(
    path.join(projectPath, 'project-config.json'),
    JSON.stringify(projectConfig, null, 2)
  );
  
  // Initialize project documentation
  const projectReadme = `# ${projectConfig.projectName}

## Project Overview
- **Client:** ${clientId}
- **Project ID:** ${projectId}
- **Domain:** ${projectConfig.domain}
- **Status:** ${projectConfig.status}

## Knowledge Architecture
This project maintains isolated knowledge while accessing universal core intelligence.

### Project-Specific Knowledge
- Business logic and domain rules
- Design system and branding
- Custom requirements and constraints
- Client-specific integrations

### Shared Universal Knowledge
- Technical standards and best practices
- Security protocols and frameworks
- Development methodologies
- System architecture patterns

## Agent Configuration
Primary agents assigned: ${projectConfig.agentConfiguration.primaryAgents.join(', ')}

## Created
${projectConfig.createdAt}

---
*Generated by AlexAI Project Context Management*`;

  await fs.writeFile(
    path.join(projectPath, 'README.md'),
    projectReadme
  );
  
  return NextResponse.json({
    success: true,
    message: 'Project created successfully',
    projectPath,
    projectConfig,
    timestamp: new Date().toISOString()
  });
}

async function getProjectContext(clientId: string, projectId: string) {
  const projectPath = path.join(
    process.cwd(),
    'alexai-knowledge-base',
    'projects',
    clientId,
    projectId
  );
  
  try {
    const configPath = path.join(projectPath, 'project-config.json');
    const configContent = await fs.readFile(configPath, 'utf-8');
    const projectConfig = JSON.parse(configContent);
    
    // Get available knowledge assets for this project
    const knowledgeAssets = await getProjectKnowledgeAssets(projectPath);
    
    // Get agent memories for this project
    const agentMemories = await getProjectAgentMemories(projectPath);
    
    return NextResponse.json({
      projectConfig,
      knowledgeAssets,
      agentMemories,
      accessibleUniversalKnowledge: [
        '01-foundations',
        '02-ai-agents/capabilities',
        '03-operations/procedures',
        '06-reference'
      ],
      isolatedKnowledge: [
        `projects/${clientId}/${projectId}`
      ],
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    return NextResponse.json(
      { error: 'Project not found or inaccessible' },
      { status: 404 }
    );
  }
}

async function switchProjectContext(clientId: string, projectId: string, contextSwitch: any) {
  // Implementation for project context switching
  // This would integrate with the observation lounge for agent alignment
  
  const switchResult = {
    previousContext: contextSwitch.previousContext || null,
    newContext: {
      clientId,
      projectId,
      switchedAt: new Date().toISOString()
    },
    agentRealignment: {
      status: 'initiated',
      observationLoungeSession: `project-switch-${Date.now()}`,
      agentsToRealign: contextSwitch.agents || ['all']
    },
    knowledgeContextUpdate: {
      isolatedKnowledge: `projects/${clientId}/${projectId}`,
      sharedKnowledge: 'universal-core',
      memoryIsolation: true
    }
  };
  
  return NextResponse.json({
    success: true,
    contextSwitch: switchResult,
    message: 'Project context switched successfully',
    recommendations: [
      'Initiate observation lounge session for agent alignment',
      'Verify agent memory isolation is active',
      'Load project-specific LCARS configuration',
      'Update Ships Computer interface for new project context'
    ],
    timestamp: new Date().toISOString()
  });
}

async function getProjectKnowledgeAssets(projectPath: string) {
  const assets = {
    businessLogic: [] as string[],
    designSystem: [] as string[],
    requirements: [] as string[],
    workflows: [] as string[],
    documentation: [] as string[]
  };
  
  try {
    const directories = Object.keys(assets);
    
    for (const dir of directories) {
      const dirPath = path.join(projectPath, dir);
      try {
        const files = await fs.readdir(dirPath);
        assets[dir as keyof typeof assets] = files.filter(file => 
          file.endsWith('.md') || file.endsWith('.json') || file.endsWith('.txt')
        );
      } catch {
        // Directory doesn't exist or is empty
        assets[dir as keyof typeof assets] = [];
      }
    }
  } catch (error) {
    console.error('Error reading project assets:', error);
  }
  
  return assets;
}

async function getProjectAgentMemories(projectPath: string) {
  const memoriesPath = path.join(projectPath, 'agent-memories');
  
  try {
    const memoryFiles = await fs.readdir(memoriesPath);
    const memories: Record<string, any> = {};
    
    for (const file of memoryFiles) {
      if (file.endsWith('.json')) {
        const agentName = file.replace('.json', '');
        const memoryContent = await fs.readFile(
          path.join(memoriesPath, file),
          'utf-8'
        );
        memories[agentName] = JSON.parse(memoryContent);
      }
    }
    
    return memories;
  } catch {
    return {};
  }
}

async function listAllProjects() {
  const projectsPath = path.join(process.cwd(), 'alexai-knowledge-base', 'projects');
  
  try {
    const clients = await fs.readdir(projectsPath);
    const allProjects = [];
    
    for (const clientId of clients) {
      const clientPath = path.join(projectsPath, clientId);
      try {
        const projects = await fs.readdir(clientPath);
        
        for (const projectId of projects) {
          const configPath = path.join(clientPath, projectId, 'project-config.json');
          try {
            const configContent = await fs.readFile(configPath, 'utf-8');
            const config = JSON.parse(configContent);
            allProjects.push({
              clientId,
              projectId,
              projectName: config.projectName,
              domain: config.domain,
              status: config.status,
              createdAt: config.createdAt
            });
          } catch {
            // Config file doesn't exist or is malformed
            allProjects.push({
              clientId,
              projectId,
              projectName: projectId,
              domain: 'unknown',
              status: 'needs-configuration',
              createdAt: 'unknown'
            });
          }
        }
      } catch {
        // Client directory doesn't exist or is inaccessible
      }
    }
    
    return NextResponse.json({
      projects: allProjects,
      total: allProjects.length,
      timestamp: new Date().toISOString()
    });
    
  } catch {
    return NextResponse.json({
      projects: [],
      total: 0,
      message: 'No projects found or projects directory not accessible',
      timestamp: new Date().toISOString()
    });
  }
}

async function listAllClients() {
  const projectsPath = path.join(process.cwd(), 'alexai-knowledge-base', 'projects');
  
  try {
    const clients = await fs.readdir(projectsPath);
    const clientData = [];
    
    for (const clientId of clients) {
      const clientPath = path.join(projectsPath, clientId);
      try {
        const projects = await fs.readdir(clientPath);
        clientData.push({
          clientId,
          projectCount: projects.length,
          projects: projects
        });
      } catch {
        clientData.push({
          clientId,
          projectCount: 0,
          projects: []
        });
      }
    }
    
    return NextResponse.json({
      clients: clientData,
      total: clientData.length,
      timestamp: new Date().toISOString()
    });
    
  } catch {
    return NextResponse.json({
      clients: [],
      total: 0,
      message: 'No clients found or projects directory not accessible',
      timestamp: new Date().toISOString()
    });
  }
}

async function getClientProjects(clientId: string) {
  try {
    const projectsDir = path.join(process.cwd(), 'alexai-knowledge-base', 'projects', clientId);
    const projects = await fs.readdir(projectsDir);
    
    const projectData = [];
    
    for (const projectId of projects) {
      try {
        const projectPath = path.join(projectsDir, projectId);
        const configPath = path.join(projectPath, 'project-config.json');
        const configContent = await fs.readFile(configPath, 'utf-8');
        const config = JSON.parse(configContent);
        
        projectData.push({
          projectId,
          ...config
        });
      } catch {
        projectData.push({
          projectId,
          status: 'unknown',
          createdAt: new Date().toISOString()
        });
      }
    }
    
    return NextResponse.json({
      clientId,
      projects: projectData,
      total: projectData.length,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    return NextResponse.json({
      error: 'Failed to retrieve client projects',
      clientId,
      projects: [],
      total: 0,
      timestamp: new Date().toISOString()
    }, { status: 500 });
  }
}

async function getProjectsOverview() {
  return NextResponse.json({
    message: 'AlexAI Multi-Project Intelligence Platform',
    capabilities: [
      'Multi-client project isolation',
      'Universal knowledge sharing',
      'Project-specific agent configuration',
      'Dynamic LCARS interface adaptation',
      'Cross-project learning (anonymized)',
      'Observation lounge project alignment'
    ],
    availableActions: [
      'create-project',
      'switch-context', 
      'update-project',
      'list-projects',
      'list-clients'
    ],
    timestamp: new Date().toISOString()
  });
}

async function updateProjectContext(clientId: string, projectId: string, projectData: any) {
  // Implementation for updating project configuration
  const projectPath = path.join(
    process.cwd(),
    'alexai-knowledge-base',
    'projects',
    clientId,
    projectId
  );
  
  try {
    const configPath = path.join(projectPath, 'project-config.json');
    const existingConfig = JSON.parse(await fs.readFile(configPath, 'utf-8'));
    
    const updatedConfig = {
      ...existingConfig,
      ...projectData,
      updatedAt: new Date().toISOString()
    };
    
    await fs.writeFile(configPath, JSON.stringify(updatedConfig, null, 2));
    
    return NextResponse.json({
      success: true,
      message: 'Project updated successfully',
      updatedConfig,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to update project' },
      { status: 500 }
    );
  }
}

async function archiveProject(clientId: string, projectId: string) {
  // Implementation for archiving projects
  return NextResponse.json({
    success: true,
    message: 'Project archive functionality to be implemented',
    clientId,
    projectId,
    timestamp: new Date().toISOString()
  });
}
